<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.175">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="AF &amp; CL">

<title>MatchIt distances</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="example-rf_files/libs/clipboard/clipboard.min.js"></script>
<script src="example-rf_files/libs/quarto-html/quarto.js"></script>
<script src="example-rf_files/libs/quarto-html/popper.min.js"></script>
<script src="example-rf_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="example-rf_files/libs/quarto-html/anchor.min.js"></script>
<link href="example-rf_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="example-rf_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="example-rf_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="example-rf_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="example-rf_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#problema" id="toc-problema" class="nav-link active" data-scroll-target="#problema">Problema</a></li>
  <li><a href="#esempio-con-distanza" id="toc-esempio-con-distanza" class="nav-link" data-scroll-target="#esempio-con-distanza">Esempio (con distanza)</a></li>
  <li><a href="#documentazione" id="toc-documentazione" class="nav-link" data-scroll-target="#documentazione">Documentazione</a></li>
  <li><a href="#test-rf" id="toc-test-rf" class="nav-link" data-scroll-target="#test-rf">Test (RF)</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MatchIt distances</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>AF &amp; CL </p>
          </div>
  </div>
    
    
  </div>
  

</header>

<section id="problema" class="level2">
<h2 class="anchored" data-anchor-id="problema">Problema</h2>
<p>Provare a cambiare la <em>distanza</em> utilizzata dal pacchetto <code>{MatchIt}</code>.</p>
<p>Iniziamo guardando la documentazione per trovare un esempio</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MatchIt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>?matchit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="esempio-con-distanza" class="level2">
<h2 class="anchored" data-anchor-id="esempio-con-distanza">Esempio (con distanza)</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"lalonde"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>m.out2 <span class="ot">&lt;-</span> <span class="fu">matchit</span>(treat <span class="sc">~</span> age <span class="sc">+</span> educ <span class="sc">+</span> race <span class="sc">+</span> nodegree <span class="sc">+</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                   married <span class="sc">+</span> re74 <span class="sc">+</span> re75, <span class="at">data =</span> lalonde,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                   <span class="at">distance =</span> <span class="st">"mahalanobis"</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">exact =</span> <span class="sc">~</span> married <span class="sc">+</span> race)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>m.out2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A matchit object
 - method: 1:1 nearest neighbor matching with replacement
 - distance: Mahalanobis
 - number of obs.: 614 (original), 263 (matched)
 - target estimand: ATT
 - covariates: age, educ, race, nodegree, married, re74, re75</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(m.out2, <span class="at">un =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
matchit(formula = treat ~ age + educ + race + nodegree + married + 
    re74 + re75, data = lalonde, distance = "mahalanobis", exact = ~married + 
    race, replace = TRUE)

Summary of Balance for All Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
age              25.8162       28.0303         -0.3094     0.4400    0.0813
educ             10.3459       10.2354          0.0550     0.4959    0.0347
raceblack         0.8432        0.2028          1.7615          .    0.6404
racehispan        0.0595        0.1422         -0.3498          .    0.0827
racewhite         0.0973        0.6550         -1.8819          .    0.5577
nodegree          0.7081        0.5967          0.2450          .    0.1114
married           0.1892        0.5128         -0.8263          .    0.3236
re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248
re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342
           eCDF Max
age          0.1577
educ         0.1114
raceblack    0.6404
racehispan   0.0827
racewhite    0.5577
nodegree     0.1114
married      0.3236
re74         0.4470
re75         0.2876


Summary of Balance for Matched Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
age              25.8162       25.5946          0.0310     0.6489    0.0472
educ             10.3459       10.3946         -0.0242     1.1553    0.0065
raceblack         0.8432        0.8432          0.0000          .    0.0000
racehispan        0.0595        0.0595         -0.0000          .    0.0000
racewhite         0.0973        0.0973          0.0000          .    0.0000
nodegree          0.7081        0.7135         -0.0119          .    0.0054
married           0.1892        0.1892          0.0000          .    0.0000
re74           2095.5737     1861.6424          0.0479     1.4963    0.0286
re75           1532.0553     1091.6516          0.1368     2.0314    0.0347
           eCDF Max Std. Pair Dist.
age          0.1838          0.4918
educ         0.0324          0.2070
raceblack    0.0000          0.0000
racehispan   0.0000          0.0000
racewhite    0.0000          0.0000
nodegree     0.0054          0.0119
married      0.0000          0.0000
re74         0.1784          0.2606
re75         0.0811          0.2445

Sample Sizes:
              Control Treated
All            429.       185
Matched (ESS)   33.72     185
Matched         78.       185
Unmatched      351.         0
Discarded        0.         0</code></pre>
</div>
</div>
</section>
<section id="documentazione" class="level2">
<h2 class="anchored" data-anchor-id="documentazione">Documentazione</h2>
<blockquote class="blockquote">
<p>the distance measure to be used. Can be either the name of a method of estimating propensity scores (e.g., “glm”), the name of a method of computing a distance matrix from the covariates (e.g., “mahalanobis”), a vector of already-computed distance measures, or a matrix of pairwise distances. See distance for allowable options. The default is “glm” for propensity scores estimated with logistic regression using glm(). Ignored for some methods; see individual methods pages for information on whether and how the distance measure is used.</p>
</blockquote>
<p>Andiamo a vedere quali sono i metodi ci sono facendo click (sulla documentazione) sulla parola <code>distance</code></p>
<blockquote class="blockquote">
<p>Propensity scores and other distance measures</p>
<p>Description</p>
<p>Several matching methods require or can involve the distance between treated and control units. Options include the Mahalanobis distance, propensity score distance, or distance between user-supplied values. Propensity scores are also used for common support via the discard options and for defining calipers. This page documents the options that can be supplied to the distance argument to matchit().</p>
<p>Allowable options</p>
<p>There are four ways to specify the distance argument: 1) as a string containing the name of a method for estimating propensity scores, 2) as a string containing the name of a method for computing pairwise distances from the covariates, 3) as a vector of values whose pairwise differences define the distance between units, or 4) as a distance matrix containing all pairwise distances. The options are detailed below.</p>
<p>Propensity score estimation methods</p>
<p>When distance is specified as the name of a method for estimating propensity scores (described below), a propensity score is estimated using the variables in formula and the method corresponding to the given argument. This propensity score can be used to compute the distance between units as the absolute difference between the propensity scores of pairs of units. Propensity scores can also be used to create calipers and common support restrictions, whether or not they are used in the actual distance measure used in the matching, if any.</p>
<p>In addition to the distance argument, two other arguments can be specified that relate to the estimation and manipulation of the propensity scores. The link argument allows for different links to be used in models that require them such as generalized linear models, for which the logit and probit links are allowed, among others. In addition to specifying the link, the link argument can be used to specify whether the propensity score or the linearized version of the propensity score should be used; by specifying link = “linear.{link}”, the linearized version will be used.</p>
<p>The distance.options argument can also be specified, which should be a list of values passed to the propensity score-estimating function, for example, to choose specific options or tuning parameters for the estimation method. If formula, data, or verbose are not supplied to distance.options, the corresponding arguments from matchit() will be automatically supplied. See the Examples for demonstrations of the uses of link and distance.options. When s.weights is supplied in the call to matchit(), it will automatically be passed to the propensity score-estimating function as the weights argument unless otherwise described below.</p>
<p>The following methods for estimating propensity scores are allowed:</p>
<p>“glm”</p>
<p>The propensity scores are estimated using a generalized linear model (e.g., logistic regression). The formula supplied to matchit() is passed directly to glm(), and predict.glm() is used to compute the propensity scores. The link argument can be specified as a link function supplied to binomial(), e.g., “logit”, which is the default. When link is prepended by “linear.”, the linear predictor is used instead of the predicted probabilities. distance = “glm” with link = “logit” (logistic regression) is the default in matchit().</p>
<p>“gam”</p>
<p>The propensity scores are estimated using a generalized additive model. The formula supplied to matchit() is passed directly to mgcv::gam(), and mgcv::predict.gam() is used to compute the propensity scores. The link argument can be specified as a link function supplied to binomial(), e.g., “logit”, which is the default. When link is prepended by “linear.”, the linear predictor is used instead of the predicted probabilities. Note that unless the smoothing functions mgcv::s(), mgcv::te(), mgcv::ti(), or mgcv::t2() are used in formula, a generalized additive model is identical to a generalized linear model and will estimate the same propensity scores as glm. See the documentation for mgcv::gam(), mgcv::formula.gam(), and mgcv::gam.models() for more information on how to specify these models. Also note that the formula returned in the matchit() output object will be a simplified version of the supplied formula with smoothing terms removed (but all named variables present).</p>
<p>“gbm”</p>
<p>The propensity scores are estimated using a generalized boosted model. The formula supplied to matchit() is passed directly to gbm::gbm(), and gbm::predict.gbm() is used to compute the propensity scores. The optimal tree is chosen using 5-fold cross-validation by default, and this can be changed by supplying an argument to method to distance.options; see gbm::gbm.perf() for details. The link argument can be specified as “linear” to use the linear predictor instead of the predicted probabilities. No other links are allowed. The tuning parameter defaults differ from gbm::gbm(); they are as follows: n.trees = 1e4, interaction.depth = 3, shrinkage = .01, bag.fraction = 1, cv.folds = 5, keep.data = FALSE. These are the same defaults as used in WeightIt and twang, except for cv.folds and keep.data. Note this is not the same use of generalized boosted modeling as in twang; here, the number of trees is chosen based on cross-validation or out-of-bag error, rather than based on optimizing balance. twang should not be cited when using this method to estimate propensity scores.</p>
<p>“lasso”, “ridge”, “elasticnet”</p>
<p>The propensity scores are estimated using a lasso, ridge, or elastic net model, respectively. The formula supplied to matchit() is processed with model.matrix() and passed to glmnet::cv.glmnet(), and glmnet::predict.cv.glmnet() is used to compute the propensity scores. The link argument can be specified as a link function supplied to binomial(), e.g., “logit”, which is the default. When link is prepended by “linear.”, the linear predictor is used instead of the predicted probabilities. When link = “log”, a Poisson model is used. For distance = “elasticnet”, the alpha argument, which controls how to prioritize the lasso and ridge penalties in the elastic net, is set to .5 by default and can be changed by supplying an argument to alpha in distance.options. For “lasso” and “ridge”, alpha is set to 1 and 0, respectively, and cannot be changed. The cv.glmnet() defaults are used to select the tuning parameters and generate predictions and can be modified using distance.options. If the s argument is passed to distance.options, it will be passed to predict.cv.glmnet(). Note that because there is a random component to choosing the tuning parameter, results will vary across runs unless a seed is set.</p>
<p>“rpart”</p>
<p>The propensity scores are estimated using a classification tree. The formula supplied to matchit() is passed directly to rpart::rpart(), and rpart::predict.rpart() is used to compute the propensity scores. The link argument is ignored, and predicted probabilities are always returned as the distance measure.</p>
<p>“randomforest”</p>
<p>The propensity scores are estimated using a random forest. The formula supplied to matchit() is passed directly to randomForest::randomForest(), and randomForest::predict.randomForest() is used to compute the propensity scores. The link argument is ignored, and predicted probabilities are always returned as the distance measure.</p>
<p>“nnet”</p>
<p>The propensity scores are estimated using a single-hidden-layer neural network. The formula supplied to matchit() is passed directly to nnet::nnet(), and fitted() is used to compute the propensity scores. The link argument is ignored, and predicted probabilities are always returned as the distance measure. An argument to size must be supplied to distance.options when using method = “nnet”.</p>
<p>“cbps”</p>
<p>The propensity scores are estimated using the covariate balancing propensity score (CBPS) algorithm, which is a form of logistic regression where balance constraints are incorporated to a generalized method of moments estimation of of the model coefficients. The formula supplied to matchit() is passed directly to CBPS::CBPS(), and fitted is used to compute the propensity scores. The link argument can be specified as “linear” to use the linear predictor instead of the predicted probabilities. No other links are allowed. The estimand argument supplied to matchit() will be used to select the appropriate estimand for use in defining the balance constraints, so no argument needs to be supplied to ATT in CBPS.</p>
<p>“bart”</p>
<p>The propensity scores are estimated using Bayesian additive regression trees (BART). The formula supplied to matchit() is passed directly to dbarts::bart2(), and dbarts::fitted() is used to compute the propensity scores. The link argument can be specified as “linear” to use the linear predictor instead of the predicted probabilities. When s.weights is supplied to matchit(), it will not be passed to bart2 because the weights argument in bart2 does not correspond to sampling weights.</p>
<p>Methods for computing distances from covariates</p>
<p>The following methods involve computing a distance matrix from the covariates themselves without estimating a propensity score. Calipers on the distance measure and common support restrictions cannot be used, and the distance component of the output object will be empty because no propensity scores are estimated. The link and distance.options arguments are ignored with these methods. See the individual matching methods pages for whether these distances are allowed and how they are used. Each of these distance measures can also be calculated outside matchit() using its corresponding function.</p>
<p>“euclidean”</p>
<p>The Euclidean distance is the raw distance between units, computed as</p>
<p>…</p>
<p>It is sensitive to the scale of the covariates, so covariates with larger scales will take higher priority.</p>
<p>“scaled_euclidean”</p>
<p>The scaled Euclidean distance is the Euclidean distance computed on the scaled (i.e., standardized) covariates. This ensures the covariates are on the same scale. The covariates are standardized using the pooled within-group standard deviations, computed by treatment group-mean centering each covariate before computing the standard deviation in the full sample.</p>
<p>“mahalanobis”</p>
<p>The Mahalanobis distance is computed as</p>
<p>…</p>
<p>​where \SigmaΣ is the pooled within-group covariance matrix of the covariates, computed by treatment group-mean centering each covariate before computing the covariance in the full sample. This ensures the variables are on the same scale and accounts for the correlation between covariates.</p>
<p>“robust_mahalanobis”</p>
<p>The robust rank-based Mahalanobis distance is the Mahalanobis distance computed on the ranks of the covariates with an adjustment for ties. It is described in Rosenbaum (2010, ch.&nbsp;8) as an alternative to the Mahalanobis distance that handles outliers and rare categories better than the standard Mahalanobis distance but is not affinely invariant.</p>
<p>To perform Mahalanobis distance matching and estimate propensity scores to be used for a purpose other than matching, the mahvars argument should be used along with a different specification to distance. See the individual matching method pages for details on how to use mahvars.</p>
<p>Distances supplied as a numeric vector or matrix</p>
<p>distance can also be supplied as a numeric vector whose values will be taken to function like propensity scores; their pairwise difference will define the distance between units. This might be useful for supplying propensity scores computed outside matchit() or resupplying matchit() with propensity scores estimated previously without having to recompute them.</p>
<p>distance can also be supplied as a matrix whose values represent the pairwise distances between units. The matrix should either be a square, with a row and column for each unit (e.g., as the output of a call to as.matrix(dist(.))), or have as many rows as there are treated units and as many columns as there are control units (e.g., as the output of a call to mahalanobis_dist() or optmatch::match_on()). Distance values of Inf will disallow the corresponding units to be matched. When distance is a supplied as a numeric vector or matrix, link and distance.options are ignored.</p>
<p>Outputs</p>
<p>When specifying an argument to distance that estimates a propensity score, the output of the function called to estimate the propensity score (e.g., the glm object when distance = “glm”) will be included in the matchit() output object in the model component. When distance propensity score estimation method or a vector of distance values, the estimated or supplied distance measures will be included in the matchit() output object in the distance component. Otherwise, the distance component will be empty.</p>
<p>Note</p>
<p>In versions of MatchIt prior to 4.0.0, distance was specified in a slightly different way. When specifying arguments using the old syntax, they will automatically be converted to the corresponding method in the new syntax but a warning will be thrown. distance = “logit”, the old default, will still work in the new syntax, though distance = “glm”, link = “logit” is preferred (note that these are the default settings and don’t need to be made explicit).</p>
</blockquote>
</section>
<section id="test-rf" class="level2">
<h2 class="anchored" data-anchor-id="test-rf">Test (RF)</h2>
<p>Proviamo dunque con <code>randoforest</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>m.out.rf <span class="ot">&lt;-</span> <span class="fu">matchit</span>(treat <span class="sc">~</span> age <span class="sc">+</span> educ <span class="sc">+</span> race <span class="sc">+</span> nodegree <span class="sc">+</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                   married <span class="sc">+</span> re74 <span class="sc">+</span> re75, <span class="at">data =</span> lalonde,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">distance =</span> <span class="st">"randomforest"</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">exact =</span> <span class="sc">~</span> married <span class="sc">+</span> race)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>m.out.rf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A matchit object
 - method: 1:1 nearest neighbor matching with replacement
 - distance: Propensity score
             - estimated with a random forest
 - number of obs.: 614 (original), 255 (matched)
 - target estimand: ATT
 - covariates: age, educ, race, nodegree, married, re74, re75</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(m.out.rf, <span class="at">un =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
matchit(formula = treat ~ age + educ + race + nodegree + married + 
    re74 + re75, data = lalonde, distance = "randomforest", exact = ~married + 
    race, replace = TRUE)

Summary of Balance for All Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
distance          0.6855        0.1656          1.9024     1.3448    0.4429
age              25.8162       28.0303         -0.3094     0.4400    0.0813
educ             10.3459       10.2354          0.0550     0.4959    0.0347
raceblack         0.8432        0.2028          1.7615          .    0.6404
racehispan        0.0595        0.1422         -0.3498          .    0.0827
racewhite         0.0973        0.6550         -1.8819          .    0.5577
nodegree          0.7081        0.5967          0.2450          .    0.1114
married           0.1892        0.5128         -0.8263          .    0.3236
re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248
re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342
           eCDF Max
distance     0.6978
age          0.1577
educ         0.1114
raceblack    0.6404
racehispan   0.0827
racewhite    0.5577
nodegree     0.1114
married      0.3236
re74         0.4470
re75         0.2876


Summary of Balance for Matched Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
distance          0.6855        0.6816          0.0144     0.9861    0.0087
age              25.8162       26.3405         -0.0733     0.6120    0.0345
educ             10.3459       10.3568         -0.0054     0.5341    0.0313
raceblack         0.8432        0.8432          0.0000          .    0.0000
racehispan        0.0595        0.0595          0.0000          .    0.0000
racewhite         0.0973        0.0973          0.0000          .    0.0000
nodegree          0.7081        0.6162          0.2021          .    0.0919
married           0.1892        0.1892          0.0000          .    0.0000
re74           2095.5737     2298.1880         -0.0415     0.9648    0.0173
re75           1532.0553     1403.6418          0.0399     1.7364    0.0251
           eCDF Max Std. Pair Dist.
distance     0.0757          0.0432
age          0.1081          1.1370
educ         0.0919          1.2582
raceblack    0.0000          0.0000
racehispan   0.0000          0.0000
racewhite    0.0000          0.0000
nodegree     0.0919          0.9631
married      0.0000          0.0000
re74         0.0595          0.6590
re75         0.0703          0.5641

Sample Sizes:
              Control Treated
All            429.       185
Matched (ESS)   30.53     185
Matched         70.       185
Unmatched      359.         0
Discarded        0.         0</code></pre>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>